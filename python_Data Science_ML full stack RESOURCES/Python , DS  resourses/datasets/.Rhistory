t.test(len~dose, paired = FALSE , var.equal = FALSE, data = OJ_VAL)
OJ_VAL = filter(ToothGrowth, dose >1.5, supp=="OJ")
OJ_VAL = filter(ToothGrowth, dose <2, supp=="OJ")
OJ_high_dose = filter(ToothGrowth, dose >1.5, supp=="OJ")
t.test(len~dose, paired = FALSE , var.equal = FALSE, data = OJ_high_dose)
View(OJ_high_dose)
View(OJ_high_dose)
OJ_high_dose = filter(ToothGrowth, dose >0.5, supp=="OJ")
t.test(len~dose, paired = FALSE , var.equal = FALSE, data = OJ_high_dose)
library(ggplot2)
library(dplyr)
data(ToothGrowth)
View(ToothGrowth)
summary(ToothGrowth)
g<- ggplot(ToothGrowth, aes(x=dose, y = len))
print(g)
g<- ggplot(ToothGrowth, aes(x=dose, y = len))+ geom_point(aes(color=supp))
print(g)
a<- ToothGrowth %>% group_by(supp,dose) %>%
validate_grouped_df()
l
library(ggplot2)
library(dplyr)
data(ToothGrowth)
summary(ToothGrowth)
g<- ggplot(ToothGrowth, aes(x=dose, y = len))+ geom_point(aes(color=supp))
print(g)
a<- ToothGrowth %>% group_by(supp,dose)
View(a)
a<- ToothGrowth %>% group_by(supp,dose) %>% summarise(lenmean = mean(len), lensd = sd(len))
View(a)
View(a)
a<- ToothGrowth %>% group_by(supp,dose) %>% summarise(lenmean = mean(len), lensd = sd(len))
b<- ToothGrowth %>% group_by(supp) %>% summarise(lenmean = mean(len), lensd = sd(len))
View(b)
c<- ToothGrowth %>% group_by(dose) %>% summarise(lenmean = mean(len), lensd = sd(len))
View(c)
t.test(len~supp,paired=FALSE, var.equal = FALSE ,data= ToothGrowth )
T_half = ToothGrowth[ToothGrowth$dose == 0.5]
T_half <- ToothGrowth[ToothGrowth$dose == 0.5]
T_half <- ToothGrowth[ToothGrowth$dose == 0.5,]
View(T_half)
t.test(len~supp,paired=FALSE, var.equal = FALSE ,data= T_half )
T_one <- ToothGrowth[ToothGrowth$dose == 1,]
t.test(len~supp,paired=FALSE, var.equal = FALSE ,data= T_one )
T_two <- ToothGrowth[ToothGrowth$dose == 2,]
t.test(len~supp,paired=FALSE, var.equal = FALSE ,data= T_two )
t.test(len~supp,paired=FALSE, var.equal = FALSE ,data= T_one )
T_half <- ToothGrowth[ToothGrowth$dose == 0.5,]
t.test(len~supp,paired=FALSE, var.equal = FALSE ,data= T_half )
T_OJ <- ToothGrowth[ToothGrowth$supp == 'OJ',]
t.test(len~supp,paired=FALSE, var.equal = FALSE ,data= T_OJ )
t.test(len~does,paired=FALSE, var.equal = FALSE ,data= T_OJ )
t.test(len~does,paired=FALSE, var.equal = FALSE ,data= T_OJ )
t.test(len~dose,paired=FALSE, var.equal = FALSE ,data= T_OJ )
View(T_OJ)
View(T_OJ)
View(T_OJ)
T_OJ <- filter([ToothGrowth, dose < 2  ,supp ='OJ')
T_OJ <- filter([ToothGrowth, dose < 2  ,supp =='OJ')
T_OJ <- filter(ToothGrowth, dose < 2  ,supp =='OJ')
View(T_OJ)
t.test(len~dose,paired=FALSE, var.equal = FALSE ,data= T_OJ )
T_OJ_high <- filter(ToothGrowth, dose > 0.5  ,supp =='OJ')
t.test(len~dose,paired=FALSE, var.equal = FALSE ,data= T_OJ_high )
install.packages("TTR")
library(TTR)
library(forecast)
mlb<-c(62,93,126,75,34)
mean(mlb)
median(mlb)
mode(mlb)
v <- charToRaw("Hello")
print(class(v))
print(v)
x = c(1,3,5,7)
length(x)
typeof(x)
y <- c(2,4.5,"Six",8L,T)
length(y)
typeof(y)
x = c(1,3,5,7)
y<- c(3.5,4.6,2,10)
z = x+y
z
x <- 1:10
x
seq(1,3, by=0.2)
seq(1,3, length.out =4)
x <- 1:10
x
x <- 1:10
x
x[-5]
x(c(-2,-6,-8))
x[c(-2,-6,-8)]
x <- 1:10
x
x[-5]
x[c(-2,-6,-8)]
x[4]
x[c(3,6,8,9)]
x[c(TRUE,F,F,TRUE,F,T,T)]
x <- 1:10
x
x[x<5]
x[x%2==0]
x[(x%2==0)]
x <- 1:10
x
x[(x%%2==0)]
x[(x<5) | (x>8)]
x<- c("Physics"=80, "Chemistry"=87, "Maths"=85, "English"=69)
x["Maths"]
x <- 1:10
x[4]<- NULL
x <- NULL
x
x
x <- 1:10
x
x[4]<- 40
xx <- NULL
x <- 1:10
x
x[4]<- 40
x
matrix(1:12, nrow=3, dimnames = list(c('a','b','c'), c('col1','col2','col3','col4')))
mat1<- matrix(1:12, nrow=3, dimnames = list(c('a','b','c'), c('col1','col2','col3','col4')))
View(mat1)
colnames(mat1)
rownames(mat1)
colnames(mat1) <- c('Saving','FD','RD','Loan')
colnames(mat1)
mat1<- matrix(1:12, nrow=3, dimnames = list(c('a','b','c'), c('col1','col2','col3','col4')))
colnames(mat1) <- c('Saving','FD','RD','Loan')
mat1
mat1[c(1,3),c(2,3,4)]
mat1<- matrix(1:12, nrow=3, dimnames = list(c('a','b','c'), c('col1','col2','col3','col4')))
mat1
mat1[c(T,F,T),c(T,F,T)]
mat1[mat1>5]
mat1<- matrix(1:12, nrow=3, dimnames = list(c('a','b','c'), c('col1','col2','col3','col4')))
mat1
mat1['b','col3']
mat1['b','col3'] <- 80
mat1
mat1<- matrix(1:12, nrow=3, dimnames = list(c('a','b','c'), c('col1','col2','col3','col4')))
mat1
mat1[mat1%%2==0]
mat1[mat1%%2==0]<- 100
mat1
vec <- c("A",2,"BOOK",9.6)
typeof(vec)
vec <- c("A",2,"BOOK",9.6)
typeof(vec)
vec[3]
"Reference book" -> vec[3]
vec
vec[4] <- 10.50
vec
vec <- NULL
vec <- c(T,2,10,9.6)
vec <- c(T,2,10,9.6,4.6,10.7,30.5)
vec[2:4]
vec[2:4] <-NULL
vec
ifelse(vec%%2==0, 'Even',"odd")
vec <- c(T,2,10,9.6,4.6,10.7,30.5, 30.00, 20, 57, 78)
vec <- c(T,2,97,86,10,9.6,4.6,10.7,30.5, 30.00, 20, 57, 78)
vec <- c(T,2,97,86,10,9.6,4.6,65,53,10.7,30.5, 30.00, 20, 57, 78)
ifelse(vec>=85,"Distinction","PASS")
ifelse(vec>=85,"Distinction",ifelse(vec>=65, "First","PASS"))
vec <- c(T,2,97,86,10,9.6,4.6,65,53,10.7,30.5, 30.00, 20, 57, 78)
typeof(vec)
ifelse(vec>=85,"Distinction",ifelse(vec>=65, "First",ifelse(vec>=50,"second","PASS")))
ifelse(vec>=85,"Distinction",
ifelse(vec>=65, "First",
ifelse(vec>=50,"second",
ifelse(vec>=35, "PASS","FAIL"))))
length(vec)
if(a>=100){
print("a is greater than 100")
}
a=100
b= 200
if(a>=100){
print("a is greater than 100")
}
if(a>=100){
print("a is greater than 100")
}else{
if(b<=300){
print("b is less than 300")
}
}
print("a is greater than 100")
print('b isless than300')
matrix(1:12)
matrix(1:12, nrow = 3)
mat1 <- matrix(1:12, nrow = 3, dimnames = (c("A","B","C") ,c('physics','chemistry','maths','english') ))
mat1 <- matrix(1:12, nrow = 3, dimnames = list(c("A","B","C") ,c('physics','chemistry','maths','english') ))
View(mat1)
?matrix
mat1 <- matrix(1:12, nrow = 3, byrow = T, dimnames = list(c("A","B","C") ,c('physics','chemistry','maths','english') ))
View(mat1)
View(mat1)
help(matrix)
dim(mat1)
mat1['B','Physics']
mat1['B','physics']
mat1[2,2]
mat1[c(1,2)]
mat1[c(1,2),]
mat1[c(1,2)]
mat[,]
mat1[,]
mat1[,c(1,3,4)]
mat1[-2,c(-2,-3)]
mat1
mat1
#### implementing condition on mat1
mat1[ mat1>6]
mat1['chemistry']
mat1[,'chemistry']
mat1['chemistry']
mat1['A']
mat1['A',]
mat1[mat1[,'chemistry']>6]
mat1[,'chemistry']>6
mat1
mat1[,'chemistry']>=6
mat1[mat1[,'chemistry']>=6]
mat1[mat1[,'chemistry']>=6]['chemistry']
mat1['chemistry']
mat1[,'chemistry']
mat1[,'chemistry']>=6
mat1[,'chemistry']>=6
mat1[mat1[,'chemistry']>=6]
mat1[mat1[,'chemistry']>=6]['chemistry']
mat1[mat1[,'chemistry']>=6][,'chemistry']
mat1[mat1[,'chemistry']>=6, 2]
mat1[mat1[,'chemistry']>=6, 'chemistry']
a=10
iris
a=10
a
a
a=10
name = "shruti"
last_name = 'mistri'
s=T
new = TRUE
s= F
new = FALSE
stud_no = 10L
typeof(stud_no)
typeof(a)
class(a)
names<- c("Sarah","Shailesh","Bhagyashree","Rohan","Priyanka","Shruti")
names
names[1]
names[2]
names[3]
length(names)
typeof(names)
customer <- c(1, "Shahanwaz", 30000, 6.5, "2022-01-06")
typeof(customer)
vec <- c(T,T,F)
typeof(vec)
vec <- c(T,0,F)
typeof(vec)
vec <- c(T,stud_no,F)
typeof(vec)
vec <- c(10.5,stud_no,F)
typeof(vec)
x <- c(1,10,stud_no)
x <- c(100,11,stud_no)
y <- c(2,22,12)
p= c(10,20)
x+y -> z
x+p -> xp
x <- c(100,11,100)
x+p -> xp
coll = 1:10
coll[5]
coll[-5]
names[c(1,4,5)]
names[-c(1,4,5)]
names[c(-1,-4,-5)]
names[c(T,F,T,T,)]
names[c(T,F,T,T)]
names
names
names[c(T,F,T,T)]
names[c(T,F,T,T,T)]
length(names)
names
names[c(T,F,T,T,T,T)]
names[c(T,F,T)]
names[c(T,F)]
15%%2
15%/%2
15/2
###Arithmatic operation
## + - * /  %%  %/%
coll
coll[(coll%%2==0)]
10%%2
12%%2
13%%2
coll%%2==0
coll
coll<4
coll>7
coll[coll<4]
coll[coll>7]
coll[(coll<4)|(coll>7)]
coll[(coll<4)|(coll>7)]
coll[(coll<4)&(coll>7)]
rm 10
rm(a)
x<-NULL
#Lists - Heterogenous DataStructures which are multi-dimenstional
#lists can have a scalar / vector / a matrix / a dataframe / a list as its components
a
age
Gender
students
mtcars
mat
age = c(10,14,12,15)
Gender = c("M","F","M","M")
students = c("Nikhil","Neeta","Nachiket","Nitin")
mat = matrix(mtcard)
mat = matrix(mtcars)
list(a, age, mtcars, students, Gender, mat)->lst
#Lists - Heterogenous DataStructures which are multi-dimenstional
#lists can have a scalar / vector / a matrix / a dataframe / a list as its components
a =10
list(a, age, mtcars, students, Gender, mat)->lst
View(lst)
View(lst)
View(mat)
lst
View(lst)
lst[[1]]->v
v
class(lst[[4]])
#to change the ML marks of Raj
lst[[4]] #4th component of the list
class(lst[[4]])
lst[[4]]
lst[[4]][3]
lst[[3]]
lst[[3]]$mpg
lst
list_list = list(lst, students)
View(list_list)
length(list_list)
list_list [[1]]
list_list[[1]]->l
View(list_list)
View(list_list)
View(l)
names(list_list)=c("List", "vector")
list_list
names(list_list)=c("List_name", "vector")
names(list_list)=c("List_name", "vector")
list_list
list_list$vector
list_list[2]
list_list[[2]]
list_list[[1]]
list_list[1]
list_list[[1]]
#Apply family-------------------------------------------------------------------------------
#1. Apply function
mtcars -> MT
View(MT)
class(MT)
#margin = 2 fn has to be applied column-wise
apply(X = mtcars, MARGIN = 1, FUN = sum) #margin =1 means the fn has to be applied row-wise
apply(X = mtcars, MARGIN = 2, FUN = sum) #margin =1 means the fn has to be applied row-wise
iris
iris[,-5]
mean
apply(X = iris[,-5], MARGIN = 2, FUN = mean) #we got the col wise mean for 1st four columns
fn = function(x, y=10 )
{
(x^2+y)
}
apply(X = iris[,c(1,3)], MARGIN = 2, FUN = fn, c(5,8,6))
View(iris)
apply(X = iris[,c(1,3)], MARGIN = 2, FUN = fn, c(5,8,6)) -> abc
class(abc)
#lapply on dataframes - the fn is applied on each column ---------------------------------
#similar to apply fn(with margin = 2)
lapply(iris[,c(1,3)], fn ) -> xyz #this shows that lapply is similar to apply fn with margin = 2, just the result as a list
View(xyz)
View(MT)
rm(lst)
#how lapply is different from apply fn. for dataframes
lapply(X = mtcars[,c("cyl", "vs", "am", "gear","carb")], FUN = as.factor)-> lst
View(lst)
lst = as.data.frame(lst)
apply(X = mtcars[,c("cyl", "vs", "am", "gear","carb")], MARGIN = 2, FUN = as.factor)
apply(X = mtcars[,c("cyl", "vs", "am", "gear","carb")], MARGIN = 2, FUN = as.factor) -> abc
class(abc)
apply(iris, MARGIN = 2, FUN = summary)
#this drawback is overcome using lapply where we get the respective summaries of numerical / character columns
lapply(X = iris, summary)
strsplit(name, "[. ]")
name = "Knight, Mr. Robert J"
strsplit(name, "[. ]")
strsplit(name, "[. ]")[[1]]
strsplit(name, "[. ]")[[1]][2]
fn(name)
fn = function(name)
{
strsplit(name, "[. ]")[[1]][2]
}
fn(name)
#More applications on the above attribute
read.csv("E:\\Python\\Machine Learning\\datasets\\titanic_train.csv")->titanic_train
View(titanic_train)
lapply(X = titanic_train$Name,FUN = fn)->titanic_train$title
View(titanic_train)
getwd()
setwd('E:\\Python\\Machine Learning\\datasets')
#lapply can be used to simultaneously read multiple sheets of an excel file
excel_sheets("Superstore.xlsx")->sheets
#lapply can be used to simultaneously read multiple sheets of an excel file
excel_sheets("Superstore.xls")->sheets
library(readxl)
#lapply can be used to simultaneously read multiple sheets of an excel file
excel_sheets("Superstore.xls")->sheets
sheets
read_excel(path = "Superstore.xls", sheet = sheets[1])->p
View(p)
rm(p)
read_excel(path = "Superstore.xls", sheet = "Orders")->p
View(p)
View(p)
lapply(X = sheets, FUN = read_excel, path = "Superstore.xls", trim_ws = T)->p
View(p)
is.atomic(p)
r=5.4
is.atomic(p)
is.atomic(r)
#sapply ------- it is exactly similar to lapply - the only difference is it returns a vector
p = c("Dooley, Mr. Patrick", "Knight, Mr. Robert J", "Behr, Mr. Karl Howell")
sapply(X = p,FUN = fn)->title
#tapply - to apply the function level-wise based on a categorical column/s on a numerical column
head(iris)
tail(iris)
apply(X = iris[,c(1,3)], MARGIN = 2, FUN = fn, c(5,8,6)) -> abc
apply(X = iris[,-5], MARGIN = 2, FUN = mean) #we got the col wise mean for 1st four columns
mean(iris$Sepal.Length[iris$Species == "setosa"])
mean(iris$Sepal.Length[iris$Species == "versicolor"])
mean(iris$Sepal.Length[iris$Species == "virginica"])
tapply(X = iris$Sepal.Length,INDEX = list(iris$Species), FUN = mean)
tapply(X = iris$Sepal.Length,INDEX = list(iris$Species), FUN = fn, 0)
fn = function(x, y )
{
median(x^2+y)
}
tapply(X = iris$Sepal.Length,INDEX = list(iris$Species), FUN = fn, 0)
mtcars
?mtcars
tapply(X = mtcars$mpg,INDEX = list(gear = mtcars$gear, vs = mtcars$vs), mean)
tapply(X = mtcars$mpg,INDEX = list(gear = mtcars$gear, vs = mtcars$vs), mean)
which(names(mtcars) %in% c("gear","carb"))->cnum
View(MT)
mtcars[,-cnum]
mean(mtcars$gear)
mtcars[,-cnum]
aggregate(x = mtcars[,-cnum], by = list(gear = mtcars$gear, carb = mtcars$carb), mean)
names(mtcars)
names(mtcars) %in% c("gear")
which (names(mtcars) %in% c("gear"))
############
?aggregate
#duplicate rows in the data
ID = c(1,2,3,2,2)
Names = c("A", "B", "C","B", "B")
p = data.frame(ID, Names)
p[duplicated(p[ID, ]),]
Names = c("A", "B", "C","B", "D")
p = data.frame(ID, Names)
p
p[duplicated(p[ID, ]),]
unique(p)
#if there are duplicate columns in your data
cbind(p, ID)->p
p
p[ID, ]
duplicated(p[ID, ])
p[duplicated(p[ID, ]),]
p[,duplicated(p[ID, ])]
p[duplicated(p[ID, ]),]
p[,ID]
duplicated(p[,ID])
duplicated(p[,])
unique(p)
#Assignment: seperate out the unique columns
rbind(p,ID)
p[,duplicated(p[ID, ])]
duplicated(p[ID, ])
colnames(p)
p[duplicated(p[ ,colnames(p) ]),]
duplicated(p[ ,colnames(p) ])
